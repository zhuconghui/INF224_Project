\hypertarget{classSocketBuffer}{}\doxysection{Socket\+Buffer Class Reference}
\label{classSocketBuffer}\index{SocketBuffer@{SocketBuffer}}


{\ttfamily \#include $<$ccsocket.\+h$>$}



Collaboration diagram for Socket\+Buffer\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=218pt]{classSocketBuffer__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
SOCKSIZE \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line}} (std\+::string \&message)
\item 
SOCKSIZE \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line}} (const std\+::string \&message)
\item 
SOCKSIZE \mbox{\hyperlink{classSocketBuffer_ae8a72a818dfb3a0986dc72a2e0ca5a87}{read}} (char $\ast$buffer, size\+\_\+t len)
\item 
SOCKSIZE \mbox{\hyperlink{classSocketBuffer_ad5a49e3f1f44e735eb15d1896eebf7b3}{write}} (const char $\ast$str, size\+\_\+t len)
\item 
\mbox{\Hypertarget{classSocketBuffer_aa9c14ec14e092fc58c4363d2bbc20ffd}\label{classSocketBuffer_aa9c14ec14e092fc58c4363d2bbc20ffd}} 
\mbox{\hyperlink{classSocket}{Socket}} $\ast$ \mbox{\hyperlink{classSocketBuffer_aa9c14ec14e092fc58c4363d2bbc20ffd}{socket}} ()
\begin{DoxyCompactList}\small\item\em Returns the associated socket. \end{DoxyCompactList}\end{DoxyCompactItemize}
\textbf{ }\par
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classSocketBuffer_ac5989bcaf64234947934c7106af1cf38}{Socket\+Buffer}} (\mbox{\hyperlink{classSocket}{Socket}} $\ast$, size\+\_\+t input\+Size=8192, size\+\_\+t ouput\+Size=8192)
\item 
\mbox{\Hypertarget{classSocketBuffer_a739a80a7bb5d2603d8d0d9a88293bad8}\label{classSocketBuffer_a739a80a7bb5d2603d8d0d9a88293bad8}} 
{\bfseries Socket\+Buffer} (\mbox{\hyperlink{classSocket}{Socket}} \&, size\+\_\+t input\+Size=8192, size\+\_\+t ouput\+Size=8192)
\end{DoxyCompactItemize}

\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classSocketBuffer_a079fdc120086897d487fd5542fe57c7e}\label{classSocketBuffer_a079fdc120086897d487fd5542fe57c7e}} 
size\+\_\+t {\bfseries insize\+\_\+} \{\}
\item 
\mbox{\Hypertarget{classSocketBuffer_a2e6112608ced0e269808fe454fa2ff81}\label{classSocketBuffer_a2e6112608ced0e269808fe454fa2ff81}} 
size\+\_\+t {\bfseries outsize\+\_\+} \{\}
\item 
\mbox{\Hypertarget{classSocketBuffer_a9103ba29f1740eb1ef20500f3d1eeb92}\label{classSocketBuffer_a9103ba29f1740eb1ef20500f3d1eeb92}} 
int {\bfseries insep\+\_\+} \{\}
\item 
\mbox{\Hypertarget{classSocketBuffer_a2ce505eb4c7d94f92d910e695b327d40}\label{classSocketBuffer_a2ce505eb4c7d94f92d910e695b327d40}} 
int {\bfseries outsep\+\_\+} \{\}
\item 
\mbox{\Hypertarget{classSocketBuffer_a78f7f3187813c123cac254f6e914b9ae}\label{classSocketBuffer_a78f7f3187813c123cac254f6e914b9ae}} 
\mbox{\hyperlink{classSocket}{Socket}} $\ast$ {\bfseries sock\+\_\+} \{\}
\item 
\mbox{\Hypertarget{classSocketBuffer_a78504f4a49e11250977fab9fb56f387f}\label{classSocketBuffer_a78504f4a49e11250977fab9fb56f387f}} 
struct \mbox{\hyperlink{structInputBuffer}{Input\+Buffer}} $\ast$ {\bfseries in\+\_\+} \{\}
\item 
void \mbox{\hyperlink{classSocketBuffer_aca9ca0b2defa3b9e08bbbe6abafe3f16}{set\+Read\+Separator}} (int separ)
\item 
\mbox{\Hypertarget{classSocketBuffer_a81a0088b93fc30ebcdde8dc6841fc03d}\label{classSocketBuffer_a81a0088b93fc30ebcdde8dc6841fc03d}} 
int {\bfseries read\+Separator} () const
\item 
void \mbox{\hyperlink{classSocketBuffer_a165d87f2460de769fb09d84a46a793a4}{set\+Write\+Separator}} (int separ)
\item 
\mbox{\Hypertarget{classSocketBuffer_a8ec7db971ba2a8b11c37b55a56f77c25}\label{classSocketBuffer_a8ec7db971ba2a8b11c37b55a56f77c25}} 
int {\bfseries write\+Separator} () const
\item 
\mbox{\Hypertarget{classSocketBuffer_afed3bfc9187c207578f8ffe37c811a83}\label{classSocketBuffer_afed3bfc9187c207578f8ffe37c811a83}} 
bool {\bfseries retrieve\+Line} (std\+::string \&str, SOCKSIZE received)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Preserves record boundaries when exchanging messages between connected TCP/\+IP sockets. Ensures that one call to \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} corresponds to one and exactly one call to \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}} on the other side. By default, \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}} adds ~\newline
 at the end of each message and \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} searches for ~\newline
, \textbackslash{}r or ~\newline
\textbackslash{}r so that it can retreive the entire record. Beware messages should thus not contain these charecters.


\begin{DoxyCode}{0}
\DoxyCodeLine{ \textcolor{keywordtype}{int} main() \{}
\DoxyCodeLine{    \mbox{\hyperlink{classSocket}{Socket}} sock;}
\DoxyCodeLine{    \mbox{\hyperlink{classSocketBuffer}{SocketBuffer}} sockbuf(sock);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{int} status = sock.\mbox{\hyperlink{classSocket_a772419bd74c4fe4987d190506a64ff87}{connect}}(\textcolor{stringliteral}{"{}localhost"{}}, 3331);}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (status < 0) \{}
\DoxyCodeLine{      cerr << \textcolor{stringliteral}{"{}Could not connect"{}} << endl;}
\DoxyCodeLine{      \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{while} (cin) \{}
\DoxyCodeLine{      \textcolor{keywordtype}{string} request, response;}
\DoxyCodeLine{      cout << \textcolor{stringliteral}{"{}Request: "{}};}
\DoxyCodeLine{      getline(cin, request);}
\DoxyCodeLine{}
\DoxyCodeLine{      \textcolor{keywordflow}{if} (sockbuf.writeLine(request) < 0) \{}
\DoxyCodeLine{         cerr << \textcolor{stringliteral}{"{}Could not send message"{}} << endl;}
\DoxyCodeLine{         \textcolor{keywordflow}{return} 2;}
\DoxyCodeLine{      \}}
\DoxyCodeLine{      \textcolor{keywordflow}{if} (sockbuf.readLine(response) < 0) \{}
\DoxyCodeLine{         cerr << \textcolor{stringliteral}{"{}Couldn't receive message"{}} << endl;}
\DoxyCodeLine{         \textcolor{keywordflow}{return} 3;}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classSocketBuffer_ac5989bcaf64234947934c7106af1cf38}\label{classSocketBuffer_ac5989bcaf64234947934c7106af1cf38}} 
\index{SocketBuffer@{SocketBuffer}!SocketBuffer@{SocketBuffer}}
\index{SocketBuffer@{SocketBuffer}!SocketBuffer@{SocketBuffer}}
\doxysubsubsection{\texorpdfstring{SocketBuffer()}{SocketBuffer()}}
{\footnotesize\ttfamily Socket\+Buffer\+::\+Socket\+Buffer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classSocket}{Socket}} $\ast$}]{sock,  }\item[{size\+\_\+t}]{input\+Size = {\ttfamily 8192},  }\item[{size\+\_\+t}]{ouput\+Size = {\ttfamily 8192} }\end{DoxyParamCaption})}

Constructor. {\itshape socket} must be a connected TCP/\+IP \mbox{\hyperlink{classSocket}{Socket}}. It should {\bfseries{not}} be deleted as long as the \mbox{\hyperlink{classSocketBuffer}{Socket\+Buffer}} is used. {\itshape input\+Size} and {\itshape ouput\+Size} are the sizes of the buffers that are used internally for exchanging data. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classSocketBuffer_ae8a72a818dfb3a0986dc72a2e0ca5a87}\label{classSocketBuffer_ae8a72a818dfb3a0986dc72a2e0ca5a87}} 
\index{SocketBuffer@{SocketBuffer}!read@{read}}
\index{read@{read}!SocketBuffer@{SocketBuffer}}
\doxysubsubsection{\texorpdfstring{read()}{read()}}
{\footnotesize\ttfamily SOCKSIZE Socket\+Buffer\+::read (\begin{DoxyParamCaption}\item[{char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}

Reads exactly {\itshape len} bytes from the socket, blocks otherwise. \begin{DoxyReturn}{Returns}
see \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}\label{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}} 
\index{SocketBuffer@{SocketBuffer}!readLine@{readLine}}
\index{readLine@{readLine}!SocketBuffer@{SocketBuffer}}
\doxysubsubsection{\texorpdfstring{readLine()}{readLine()}}
{\footnotesize\ttfamily SOCKSIZE Socket\+Buffer\+::read\+Line (\begin{DoxyParamCaption}\item[{std\+::string \&}]{message }\end{DoxyParamCaption})}

Read a message from a connected socket. \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} receives one (and only one) message sent by \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}} on the other side, ie, a call to \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}} corresponds to one and exactly one call to \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} on the other side. The received data is stored in {\itshape message}. This method blocks until the message is fully received.

\begin{DoxyReturn}{Returns}
The number of bytes that were received or one of the following values\+:
\begin{DoxyItemize}
\item 0\+: shutdown\+Output() was called on the other side
\item Socket\+::\+Failed (-\/1)\+: a connection error occured
\item Socket\+::\+Invalid\+Socket (-\/2)\+: the socket is invalid. 
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
the separator (eg ~\newline
) is counted in the value returned by \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}}. 
\end{DoxyNote}
\mbox{\Hypertarget{classSocketBuffer_aca9ca0b2defa3b9e08bbbe6abafe3f16}\label{classSocketBuffer_aca9ca0b2defa3b9e08bbbe6abafe3f16}} 
\index{SocketBuffer@{SocketBuffer}!setReadSeparator@{setReadSeparator}}
\index{setReadSeparator@{setReadSeparator}!SocketBuffer@{SocketBuffer}}
\doxysubsubsection{\texorpdfstring{setReadSeparator()}{setReadSeparator()}}
{\footnotesize\ttfamily void Socket\+Buffer\+::set\+Read\+Separator (\begin{DoxyParamCaption}\item[{int}]{separ }\end{DoxyParamCaption})}

Returns/changes the separator used by \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}}. \mbox{\hyperlink{classSocketBuffer_aca9ca0b2defa3b9e08bbbe6abafe3f16}{set\+Read\+Separator()}} changes the symbol used by \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} to separate successive messages\+:
\begin{DoxyItemize}
\item if {\itshape separ} $<$ 0 (the default) \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} searches for \textbackslash{}n, \textbackslash{}r or \textbackslash{}n\textbackslash{}r.
\item if {\itshape separ} $>$= 0, \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} searches for this character to separate messages, 
\end{DoxyItemize}\mbox{\Hypertarget{classSocketBuffer_a165d87f2460de769fb09d84a46a793a4}\label{classSocketBuffer_a165d87f2460de769fb09d84a46a793a4}} 
\index{SocketBuffer@{SocketBuffer}!setWriteSeparator@{setWriteSeparator}}
\index{setWriteSeparator@{setWriteSeparator}!SocketBuffer@{SocketBuffer}}
\doxysubsubsection{\texorpdfstring{setWriteSeparator()}{setWriteSeparator()}}
{\footnotesize\ttfamily void Socket\+Buffer\+::set\+Write\+Separator (\begin{DoxyParamCaption}\item[{int}]{separ }\end{DoxyParamCaption})}

Returns/changes the separator used by \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}}. \mbox{\hyperlink{classSocketBuffer_a165d87f2460de769fb09d84a46a793a4}{set\+Write\+Separator()}} changes the character(s) used by \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}} to separate successive messages\+:
\begin{DoxyItemize}
\item if {\itshape separ} $<$ 0 (the default) \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}} inserts \textbackslash{}n\textbackslash{}r between successive lines.
\item if {\itshape separ} $>$= 0, \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}} inserts {\itshape separ} between successive lines, 
\end{DoxyItemize}\mbox{\Hypertarget{classSocketBuffer_ad5a49e3f1f44e735eb15d1896eebf7b3}\label{classSocketBuffer_ad5a49e3f1f44e735eb15d1896eebf7b3}} 
\index{SocketBuffer@{SocketBuffer}!write@{write}}
\index{write@{write}!SocketBuffer@{SocketBuffer}}
\doxysubsubsection{\texorpdfstring{write()}{write()}}
{\footnotesize\ttfamily SOCKSIZE Socket\+Buffer\+::write (\begin{DoxyParamCaption}\item[{const char $\ast$}]{str,  }\item[{size\+\_\+t}]{len }\end{DoxyParamCaption})}

Writes {\itshape len} bytes to the socket. \begin{DoxyReturn}{Returns}
see \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} 
\end{DoxyReturn}
\mbox{\Hypertarget{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}\label{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}} 
\index{SocketBuffer@{SocketBuffer}!writeLine@{writeLine}}
\index{writeLine@{writeLine}!SocketBuffer@{SocketBuffer}}
\doxysubsubsection{\texorpdfstring{writeLine()}{writeLine()}}
{\footnotesize\ttfamily SOCKSIZE Socket\+Buffer\+::write\+Line (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{message }\end{DoxyParamCaption})}

Send a message to a connected socket. \mbox{\hyperlink{classSocketBuffer_a96ba6ada0c8b57eacff2aa2e4e34c282}{write\+Line()}} sends a message that will be received by a single call of \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} on the other side,

\begin{DoxyReturn}{Returns}
see \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
if {\itshape message} contains one or several occurences of the separator, \mbox{\hyperlink{classSocketBuffer_afa3a2f239eb56c2e4fd4fa465f7fb54d}{read\+Line()}} will be called as many times on the other side. 
\end{DoxyNote}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
ccsocket.\+h\item 
ccsocket.\+cpp\end{DoxyCompactItemize}
